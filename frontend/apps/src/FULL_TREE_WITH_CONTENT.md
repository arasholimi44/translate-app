üìÅ ./
    üìÑ FULL_TREE_WITH_CONTENT.md

```md

```

    üìÑ generate_full_tree.py

```py
import os

def generate_tree_with_content(directory, output_file="FULL_TREE_WITH_CONTENT.md"):
    with open(output_file, "w", encoding="utf-8") as f:
        for root, dirs, files in os.walk(directory):
            level = root.replace(directory, "").count(os.sep)
            indent = "    " * level
            f.write(f"{indent}üìÅ {os.path.basename(root)}/\n")
            subindent = "    " * (level + 1)
            for file in files:
                filepath = os.path.join(root, file)
                f.write(f"{subindent}üìÑ {file}\n")
                try:
                    with open(filepath, "r", encoding="utf-8") as content_file:
                        f.write(f"\n```{file.split('.')[-1]}\n{content_file.read()}\n```\n\n")
                except Exception as e:
                    f.write(f"  [Error reading file: {e}]\n")

generate_tree_with_content(".")
```

    üìÅ app/
        üìÑ auth.config.ts

```ts
import Credentials from "next-auth/providers/credentials";
import type { NextAuthOptions, Session, TokenSet } from "next-auth";
import type { JWT } from "next-auth/jwt";

export const authConfig: NextAuthOptions = {
  session: {strategy: "jwt"},
  secret: process.env.NEXTAUTH_SECRET,
  providers: [
    Credentials({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "text" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        const res = await fetch(`${process.env.NEXTAUTH_URL}/api/auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials),
        });

        if (!res.ok) return null;

        const user = await res.json();
        if (user?.error) return null;

        return user;
      },
    }),
  ],
  callbacks: {
    async session({
      session,
      token,
    }: {
      session: Session;
      token: JWT;
    }) {
      if (session.user && token.sub) {
        session.user.id = token.sub;
      }
      return session;
    },
  },
  pages: {
    signIn: "/user",
    error: "/user?error=true",
  },
};
```

        üìÑ favicon.ico
  [Error reading file: 'utf-8' codec can't decode byte 0x96 in position 50: invalid start byte]
        üìÑ globals.css

```css
@import "tailwindcss";


body {
  background: #adadad;
  color: var(--foreground);
 
}

```

        üìÑ layout.tsx

```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import Link from "next/link";
import "./globals.css";
import {Amplify} from "aws-amplify"
import {ConfigureAmplify} from "@/components";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        {/* Disable browser extension interference in development */}
        {process.env.NODE_ENV === 'development' && (
          <script
            dangerouslySetInnerHTML={{
              __html: `
                Object.defineProperty(window, 'BIS', { value: null });
                Object.defineProperty(document, 'bis_skin_checked', { value: null });
              `,
            }}
          />
        )}

        <div className="flex gap-2 px-2 py-2 bg-orange-300">
          <Link href="/" prefetch={false}>Home</Link>
          <Link href="/user" prefetch={false}>User</Link>
        </div>
        
        <main className="p-4">
          {children}
        </main>
      </body>
    </html>
  );
}

```

        üìÑ middleware.ts

```ts
import NextAuth from "next-auth";
import { authConfig } from './auth.config';
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export const { auth } = NextAuth(authConfig);

export default async function middleware(req: NextRequest) {
  const session = await auth();
  const isLoggedIn = !!session?.user;
  const isAuthPage = req.nextUrl.pathname.startsWith('/user') || 
                    req.nextUrl.pathname.startsWith('/register');

  if (isAuthPage && isLoggedIn) {
    return NextResponse.redirect(new URL('/', req.url));
  }

  if (!isLoggedIn && !isAuthPage) {
    return NextResponse.redirect(new URL('/user', req.url));
  }
}
```

        üìÑ page.tsx

```tsx
"use client";
import { useState } from "react";
import {ITranslateDbObject, ITranslateRequest, ITranslateResponse} from "@sff/shared-types"

const URL ="https://qotybv8kfc.execute-api.localhost.localstack.cloud:4566/prod/"

 const translateText= async({
  inputLang,
  outputLang,
  inputText,
}: {
  inputLang: string;
  outputLang: string;
  inputText: string;

}) => {
  try{
  const request: ITranslateRequest = {
  sourceLang: inputLang,
  targetLang: outputLang,
  sourceText: inputText
  }

  const result = await fetch(URL, {
    method: "POST",
body: JSON.stringify(request),
  });

  const rtnValue = await result.json() as ITranslateResponse;
  return rtnValue;
}catch(e: unknown) {
  console.error(e);
  throw e as Error;  // Only use if you're certain
}
};

 const getTranslations= async() => {
  try{
  

  const result = await fetch(URL, {
    method: "GET",
  });

  const rtnValue = await result.json() as Array<ITranslateDbObject>;
  return rtnValue;
}catch(e: unknown) {
  console.error(e);
  throw e as Error;  // Only use if you're certain
}
};


export default function Home() {
  const [inputText, setInputText] = useState<string>("");
  const [inputLang, setInputLang] = useState<string>("");
  const [outputLang, setOutputLang] = useState<string>("");
  const [outputText, setOutputText] = useState<ITranslateResponse | null>(null);
  const [translations, setTranslations] = useState<Array<ITranslateDbObject>>([]);

  return (
      <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <form onSubmit={async (event) => {
        event?.preventDefault();
        //console.log({inputText,inputLang,outputLang});
        const result = await translateText({
          inputText,inputLang,outputLang});
          setOutputText(result);

      }}  >
        <div>
          <label htmlFor="inputText">Input Text</label>
          <textarea 
          id="inputText" 
          value= {inputText} 
          onChange={(e) => setInputText(e.target.value)} />
        </div>
        <div>
          <label htmlFor="inputLang">Input Text</label>
          <input 
          id="inputLang" 
          value= {inputLang} 
          onChange={(e) => setInputLang(e.target.value)} />
        </div>

        <div>
          <label htmlFor="outputLang">Input Text</label>
          <input 
          id="outputLang" 
          value= {outputLang} 
          onChange={(e) => setOutputLang(e.target.value)} />
        </div>

      <button className="btn bg-blue-500 p-2 mt-2 rounded-xl " type="submit"> 
        Translate</button>

      </form>

       <div>
        <p>Result:</p>
        <pre style={{whiteSpace:"pre-wrap"}} className="w-full">
        {JSON.stringify(outputText)}</pre>
        </div>

        <button className="btn bg-blue-500 p-2 mt-2 rounded-xl "
         type="button"
         onClick={async () => {
          const rtnValue = await getTranslations();
          setTranslations(rtnValue);
         }}> 
        getTranslations
        </button>

        <div>
        <p>Result:</p>
        <pre>
          {translations.map( (item) => (
            <div key={item.requestId}>
              <p>{item.sourceLang}/{item.sourceText}</p>
              <p>{item.targetLang}/{item.targetText}</p>
            </div>
          ))}
        </pre>

        {/* <pre style={{whiteSpace:"pre-wrap"}} className="w-full">
        {JSON.stringify(translations)}</pre> */}
        </div>
      
      </main>
  );
}

```

        üìÅ api/
            üìÅ auth/
                üìÅ login/
                    üìÑ route.ts

```ts
import { NextRequest, NextResponse } from "next/server";
import db from "@/lib/db"; // Use consistent import path
import bcrypt from 'bcrypt';

export async function POST(req: NextRequest) {
  const { email, password } = await req.json();

  try {
    // Validate input
    if (!email || !password) {
      return NextResponse.json(
        { error: "Email and password are required" },
        { status: 400 }
      );
    }

    // Find user
    const result = await db.query(
      'SELECT id, email, password FROM users WHERE email = $1',
      [email]
    );

    const user = result.rows[0];
    if (!user) {
      return NextResponse.json(
        { error: "Invalid credentials" },
        { status: 401 }
      );
    }

    // Compare hashed password
    const isValid = await bcrypt.compare(password, user.password);
    
    if (!isValid) {
      return NextResponse.json(
        { error: "Invalid credentials" },
        { status: 401 }
      );
    }

    // Return user data (without password)
    return NextResponse.json({
      id: user.id,
      email: user.email
    });

  } catch (error) {
    console.error("Login error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

                üìÅ nextauth/
                    üìÑ route.ts

```ts
import { authConfig } from '../../../auth.config';
import NextAuth from 'next-auth';

const handler = NextAuth(authConfig);

export { handler as GET, handler as POST };
```

                üìÅ register/
                    üìÑ route.ts

```ts
import { NextResponse } from 'next/server';
import db from "@/lib/db"; // Use consistent import path
import bcrypt from 'bcrypt';

export async function POST(request: Request) {
  try {
    const { email, password } = await request.json();
    
    // Validate input
    if (!email || !password) {
      return NextResponse.json(
        { error: 'Email and password are required' },
        { status: 400 }
      );
    }

    // Validate email format
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json(
        { error: 'Invalid email format' },
        { status: 400 }
      );
    }

    // Check if user exists
    const userExists = await db.query(
      'SELECT * FROM users WHERE email = $1', 
      [email]
    );
    
    if (userExists.rows.length > 0) {
      return NextResponse.json(
        { error: 'Email already exists' },
        { status: 409 } // More appropriate status code
      );
    }

    // Hash password and create user
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = await db.query(
      'INSERT INTO users (email, password) VALUES ($1, $2) RETURNING id, email',
      [email, hashedPassword]
    );

    return NextResponse.json({ 
      success: true,
      user: newUser.rows[0] 
    });
    
  } catch (error) {
    console.error('Registration error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

        üìÅ register/
            üìÑ layout.tsx

```tsx

export default function Layout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return <main className="flex flex-col m-8">
        {children}
        </main>;
}
```

            üìÑ page.tsx

```tsx
"use client";
import {signUp, confirmSignUp, autoSignIn, SignUpOutput, SignInOutput} from "aws-amplify/auth";
import Link from "next/link";
import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { signIn } from 'next-auth/react';


// type ISignUpState = SignUpOutput ["nextStep"];
// type ISignInState = SignInOutput ['nextStep']

// function RegistrationForm({onStepChange,}:
//   {onStepChange: (step:ISignUpState) => void;}){
//   const [email, setEmail] = useState<string>("");
//   const [password, setPassword] = useState<string>("");
//   const [password2, setPassword2] = useState<string>("");

// return(
//   <main className="flex flex-col m-8">
//   <form className="flex flex-col space-y-4" onSubmit={async (event) => {
//     event.preventDefault();
//     try{
//       if (password!==password2){throw new Error("password don't match")}

//      const {nextStep} = await signUp({
//         username:email,
//         password: password,
//         options: {
//           userAttributes:{email},
//           autoSignIn:true
//         }
//       });

//      console.log( nextStep.signUpStep);
//      onStepChange(nextStep);
//     }catch(e){}
//   }}>
  
//     <div>
//       <label htmlFor="email">E-mail:</label>
//       <input 
//       id="email"
//       type="email" 
//       value= {email} 
//       onChange={(e) => setEmail(e.target.value)} />
//     </div>

//      <div>
//       <label htmlFor="password">Password:</label>
//       <input 
//        id="password"
//        type="password" 
//        value= {password} 
//        onChange={(e) => setPassword(e.target.value)} />
//        </div>

//        <div>
//       <label htmlFor="password2">Retype Password:</label>
//       <input 
//        id="password2"
//        type="password2" 
//        value= {password2} 
//        onChange={(e) => setPassword2(e.target.value)} />
//        </div> 

//   <button className="btn bg-blue-500 p-2 mt-2 rounded-xl " type="submit"> 
//     Register</button>

//   </form>
//   <Link className="hover:underline"  href="/user">Login</Link>
//       </main>
// )}

// function ConfirmSignUp({onStepChange,}:
//   {onStepChange: (step:ISignUpState) => void;}){
//   const [verificationCode, setVerificationCode] = useState<string>("");
//   const [email, setEmail] = useState<string>("");

// return(

//   <form className="flex flex-col space-y-4" onSubmit={async (event) => {
//     event.preventDefault();
//     try{
//      const {nextStep} = await confirmSignUp({
//         confirmationCode:verificationCode,
//         username: email
//       });

//      console.log( nextStep.signUpStep);
//      onStepChange(nextStep);
//     }catch(e){}
//   }}>
  
//     <div>
//       <label htmlFor="email">E-mail:</label>
//       <input 
//       id="email"
//       type="email" 
//       value= {email} 
//       onChange={(e) => setEmail(e.target.value)} />
//     </div>

//      <div>
//       <label htmlFor="verificationCode">VerificationCode:</label>
//       <input 
//        id="verificationCode"
//        type="text" 
//        value= {verificationCode} 
//        onChange={(e) => setVerificationCode(e.target.value)} />
//        </div>

//   <button className="btn bg-blue-500 p-2 mt-2 rounded-xl " type="submit"> 
//     Verify</button>
//   </form>
      
// )}

// function AutoSignIn({onStepChange,}:
//   {onStepChange: (step:ISignInState) => void;}) {
//  useEffect (() =>{
//   const asyncSignIn = async() =>{
//   const {nextStep } = await autoSignIn();
//   console.log(nextStep);
//   onStepChange(nextStep);
//  }
//  autoSignIn
// },[]);

//   return<div>signing in...</div>
// }

// export default function Register() {
// const router = useRouter()
// const [step,setStep] = useState<ISignInState | ISignUpState | null>(null);
//   useEffect(() =>{
//   if (!step) return;
//   if ((step as ISignInState).signInStep === "DONE"){
//     router.push ("/")
//   }
//   }, 
//   [step])

 
//  if (step) {
//    if ((step as ISignUpState).signUpStep === "CONFIRM_SIGN_UP"){
//     return <ConfirmSignUp onStepChange={setStep} />
//    }

//    if ((step as ISignUpState).signUpStep === "COMPLETE_AUTO_SIGN_IN"){
//     return <AutoSignIn onStepChange={setStep}/>
//    }

//  }
  


//   return <RegistrationForm onStepChange={setStep}/>;
// }

export default function RegisterPage() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      // 1Ô∏è‚É£ Register the user
      const res = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });
      if (!res.ok) {
        const { error: msg } = await res.json();
        throw new Error(msg || 'Registration failed');
      }

      // 2Ô∏è‚É£ Auto‚Äêlogin and redirect to `/`
      await signIn('credentials', {
        email,
        password,
        redirect: true,
        callbackUrl: '/',
      });
      // (NextAuth will handle the redirect)
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <main className="flex flex-col m-8">
      <h1 className="text-2xl font-bold mb-4">Register</h1>
      {error && <div className="text-red-500 mb-4">{error}</div>}
      
      <form className="flex flex-col space-y-4" onSubmit={handleSubmit}>
        <div className="flex flex-col">
          <label htmlFor="email" className="mb-1">Email:</label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="p-2 border rounded"
          />
        </div>

        <div className="flex flex-col">
          <label htmlFor="password" className="mb-1">Password:</label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            minLength={6}
            className="p-2 border rounded"
          />
        </div>

        <button 
          type="submit" 
          disabled={loading}
          className={`p-2 mt-2 rounded-xl ${
            loading ? 'bg-gray-400' : 'bg-blue-500 hover:bg-blue-600'
          } text-white`}
        >
          {loading ? 'Registering...' : 'Register'}
        </button>
      </form>

      <Link href="/user" className="mt-4 text-blue-500 hover:underline">
        Already have an account? Login
      </Link>
    </main>
  );
}
```

        üìÅ user/
            üìÑ layout.tsx

```tsx

export default function Layout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return <main className="flex flex-col m-8">
        {children}
        </main>;
}
```

            üìÑ page.tsx

```tsx
"use client";
import { signIn } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useState } from 'react';
import Link from "next/link";

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const callbackUrl = searchParams?.get('callbackUrl') || '/';

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const result = await signIn('credentials', {
        email,
        password,
        redirect: false,
        callbackUrl: '/',
      });

      if (result?.error) {
        throw new Error(result.error);
      }

      if (result?.url) {
        router.push(result.url);
      }
    } catch (error) {  // Changed from 'err' to 'error'
      setError(error instanceof Error ? error.message : "Login failed"); // Proper error handling
    } finally {
      setLoading(false);
    }
  };

  return (
    <main className="flex flex-col m-8 max-w-md mx-auto">
      <h1 className="text-2xl font-bold mb-6">Login</h1>
      
      {error && (
        <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
          {error}
        </div>
      )}

      <form className="flex flex-col gap-4" onSubmit={handleSubmit}>
        <div className="flex flex-col">
          <label htmlFor="email" className="mb-1 font-medium">Email:</label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="p-2 border rounded focus:ring-2 focus:ring-blue-500"
          />
        </div>

        <div className="flex flex-col">
          <label htmlFor="password" className="mb-1 font-medium">Password:</label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            minLength={6}
            className="p-2 border rounded focus:ring-2 focus:ring-blue-500"
          />
        </div>

        <button
          type="submit"
          disabled={loading}
          className={`mt-4 p-2 rounded-xl text-white ${
            loading ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'
          }`}
        >
          {loading ? 'Logging in...' : 'Login'}
        </button>
      </form>

      <div className="mt-6 text-center">
        <Link 
          href="/register" 
          className="text-blue-600 hover:underline"
        >
          Don't have an account? Register
        </Link>
      </div>
    </main>
  );
}

```

    üìÅ components/
        üìÑ ConfigureAmlifyClientSide.tsx

```tsx
"use client"
import {Amplify} from "aws-amplify"

Amplify.configure({
    Auth:{
        Cognito:{
             userPoolId: "",
             userPoolClientId:"",
           
        },
    },
},
{ssr: true}
);

export function ConfigureAmplify(){
    return null;
}
```

        üìÑ index.ts

```ts
export * from "./ConfigureAmlifyClientSide"
```

    üìÅ lib/
        üìÑ db.ts

```ts
import { Pool } from 'pg';

// Global pool reference for development HMR
declare global {
  var pgPool: Pool | undefined;
}

// Helper function to parse connection options
function getDbConfig() {
  // If DATABASE_URL exists, use that
  if (process.env.DATABASE_URL) {
    return { connectionString: process.env.DATABASE_URL };
  }

  // Fall back to individual variables
  return {
    user: process.env.POSTGRES_USER || 'postgres',
    host: process.env.POSTGRES_HOST || 'localhost',
    database: process.env.POSTGRES_DB || 'myauth',
    password: process.env.POSTGRES_PASSWORD || 'mysecretpassword',
    port: Number(process.env.POSTGRES_PORT) || 5432,
  };
}

// Use existing pool if available (for HMR)
const pool = global.pgPool || new Pool(getDbConfig());

// Preserve pool in development
if (process.env.NODE_ENV === 'development') global.pgPool = pool;

export default pool;
```

    üìÅ types/
        üìÑ next-auth.d.ts

```ts
import "next-auth";

declare module "next-auth" {
  interface User {
    id: string;
  }

  interface Session {
    user: User & {
      id: string;
    };
  }
}
```

